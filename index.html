<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Generative Walkman V2</title>
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
  <style>
    body {
      height: 100vh; margin: 0; background: #111; color: white;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      text-align: center; touch-action: manipulation;
    }
    h1 { font-size: 1.2rem; margin-bottom: 5px; color: #888; }
    button {
      padding: 20px 40px; font-size: 1.2rem; cursor: pointer;
      background: #00d2ff; border: none; border-radius: 50px; 
      color: #000; font-weight: bold; margin-top: 30px;
      box-shadow: 0 0 15px rgba(0, 210, 255, 0.5);
      transition: transform 0.1s;
    }
    button:active { transform: scale(0.95); }
    
    /* ステータス表示 */
    #bpm-display { font-size: 4rem; font-weight: 800; margin: 10px 0; font-variant-numeric: tabular-nums;}
    #status-text { color: #aaa; font-size: 1rem; margin-bottom: 20px; letter-spacing: 2px; }
    
    /* メーター */
    .meter-container { 
      width: 80%; height: 30px; background: #222; 
      border-radius: 15px; overflow: hidden; margin-top: 10px; border: 1px solid #444;
    }
    .meter-fill { 
      height: 100%; width: 0%; 
      background: linear-gradient(90deg, #00d2ff, #ff0099); 
      transition: width 0.1s linear; 
    }
    .debug { font-size: 0.8rem; color: #555; margin-top: 20px; }
  </style>
</head>
<body>

  <h1>Generative Walkman</h1>
  
  <div id="bpm-display">--</div>
  <div id="status-text">TAP START TO WALK</div>

  <div class="meter-container">
    <div id="meter" class="meter-fill"></div>
  </div>
  
  <button id="playBtn">START</button>
  
  <div class="debug">Movement controls Tempo & Arrangement</div>

<script>
// ===============================
// 1. 状態変数
// ===============================
let isPlaying = false;
let permissionGranted = false; // センサー許可済みフラグ

// センサー処理用
const motionBuffer = [];
const DURATION = 2000; // 2秒間の平均
let sensorVariance = 0.0; // 計算された揺れの値
let smoothedVariance = 0.0; // 滑らかにした値

// 音楽制御用
let activity = 0.0; // 0.0(静) 〜 1.0(激)
let currentBpm = 90;

// UI要素
const playBtn = document.getElementById('playBtn');
const bpmDisplay = document.getElementById('bpm-display');
const statusText = document.getElementById('status-text');
const meterEl = document.getElementById('meter');

// ===============================
// 2. Tone.js 楽器セットアップ
// ===============================
// ※モバイルでの負荷軽減のため、少しエフェクト控えめに設定
const chordSynth = new Tone.PolySynth(Tone.Synth, {
  volume: -8,
  oscillator: { type: "fatsawtooth", count: 3, spread: 30 },
  envelope: { attack: 0.1, decay: 0.3, sustain: 0.5, release: 1 }
}).toDestination();

const melodySynth = new Tone.Synth({
  volume: -5,
  oscillator: { type: "triangle" },
  envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 1 }
}).toDestination();

// ドラム系
const kick = new Tone.MembraneSynth({ volume: -2 }).toDestination();
const snare = new Tone.NoiseSynth({ 
  volume: -10, 
  envelope: { attack: 0.001, decay: 0.2, sustain: 0 } 
}).toDestination();
const hihat = new Tone.MetalSynth({ 
  volume: -15, 
  harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5,
  envelope: { attack: 0.001, decay: 0.1, release: 0.01 }
}).toDestination();

// 音楽データ
const chords = [
  ["C3","E3","G3"], ["B2","D3","G3"], ["A2","C3","E3"], ["G2","B2","E3"],
  ["F2","A2","C3"], ["E2","G2","C3"], ["F2","A2","C3"], ["G2","B2","D3"]
];
const scaleNotes = ["C4","D4","E4","G4","A4", "C5"]; 
let prevNote = "C4";

// ===============================
// 3. センサーロジック (iOS対応版)
// ===============================
async function requestMotionPermission() {
  // iOS 13+ 対応
  if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
    try {
      const response = await DeviceMotionEvent.requestPermission();
      if (response === 'granted') {
        permissionGranted = true;
        window.addEventListener('devicemotion', handleMotion);
      } else {
        alert('センサー許可が拒否されました。設定から許可してください。');
      }
    } catch (e) {
      console.error(e);
      alert('許可リクエストに失敗しました');
    }
  } else {
    // Android / PC / iOS 12以下
    permissionGranted = true;
    window.addEventListener('devicemotion', handleMotion);
  }
}

function handleMotion(event) {
  const a = event.accelerationIncludingGravity; // 重力込みで判定（歩行振動拾いやすい）
  if (!a) return;

  const mag = Math.sqrt(a.x*a.x + a.y*a.y + a.z*a.z);
  const now = Date.now();

  motionBuffer.push({ t: now, m: mag });

  // 2秒以上前のデータを削除
  while (motionBuffer.length > 0 && motionBuffer[0].t < now - DURATION) {
    motionBuffer.shift();
  }

  // データが少なすぎる場合は処理しない
  if (motionBuffer.length < 10) return;

  // 分散（分散の平方根＝標準偏差）を計算して「揺れの大きさ」とする
  const magnitudes = motionBuffer.map(d => d.m);
  const mean = magnitudes.reduce((s, v) => s + v, 0) / magnitudes.length;
  const variance = magnitudes.reduce((s, v) => s + (v - mean) ** 2, 0) / magnitudes.length;
  
  sensorVariance = Math.sqrt(variance); 
}

// (デバッグ用) PCのマウス操作で揺れをシミュレーション
if (!window.DeviceMotionEvent || /Mac|Win/.test(navigator.platform)) {
  document.addEventListener("mousemove", (e) => {
    const ratio = e.clientX / window.innerWidth;
    sensorVariance = ratio * 8.0; // 0〜8くらいの範囲で動かす
  });
}

// ===============================
// 4. メインループ & 音楽生成
// ===============================
function updateParams() {
  if (!isPlaying) return;

  // 数値を滑らかにする
  smoothedVariance += (sensorVariance - smoothedVariance) * 0.05;

  // Activity計算 (0.0 〜 1.0)
  // 通常の歩行で Variance は 2.0〜5.0 くらい、走ると 8.0以上になる想定
  let rawAct = smoothedVariance / 6.0;
  if (rawAct > 1.0) rawAct = 1.0;
  if (rawAct < 0.0) rawAct = 0.0;
  activity = rawAct;

  // BPM計算 (90 〜 140)
  const targetBpm = 90 + (activity * 50);
  
  // Tone.jsへ適用
  Tone.Transport.bpm.rampTo(targetBpm, 0.5); // 少し滑らかにBPM変化
  currentBpm = Math.round(Tone.Transport.bpm.value);

  // UI更新
  bpmDisplay.innerText = currentBpm;
  meterEl.style.width = (activity * 100) + "%";
  
  // 状態テキスト
  if (activity < 0.2) statusText.innerText = "STANDING / SLOW";
  else if (activity < 0.7) statusText.innerText = "WALKING";
  else statusText.innerText = "RUNNING";

  requestAnimationFrame(updateParams);
}

function setupMusicSchedule() {
  // 既存のイベントをクリア
  Tone.Transport.cancel();

  // --- コード進行 ---
  Tone.Transport.scheduleRepeat((time) => {
    const bar = Math.floor(Tone.Transport.position.split(":")[0]) % 8;
    // 激しいときはコードを少し短く切る、静かなら伸ばす
    const len = activity > 0.6 ? "4n" : "1n";
    if(chords[bar]) chordSynth.triggerAttackRelease(chords[bar], len, time);
  }, "1n");

  // --- メロディ ---
  // 16分音符ごとのグリッドで確率的に鳴らす
  Tone.Transport.scheduleRepeat((time) => {
    // 確率: 静=10%, 激=60%
    const probability = 0.1 + (activity * 0.5);
    
    if (Math.random() < probability) {
      // 音の選び方（ランダム）
      const note = scaleNotes[Math.floor(Math.random() * scaleNotes.length)];
      const len = activity > 0.5 ? "16n" : "8n";
      melodySynth.triggerAttackRelease(note, len, time);
    }
  }, "16n");

  // --- ドラム ---
  Tone.Transport.scheduleRepeat((time) => {
    // 小節内の16分音符カウント (0~15)
    const tick16 = Math.floor(Tone.Transport.ticks / (Tone.Transport.PPQ / 4)) % 16;

    // パターン生成ロジック
    let k = false, s = false, h = false;

    if (activity < 0.3) {
      // 静か: キック少なめ
      if (tick16 === 0) k = true;
      if (tick16 % 4 === 0) h = true;
    } else if (activity < 0.7) {
      // 歩行: 基本的なビート
      if (tick16 === 0 || tick16 === 10) k = true;
      if (tick16 === 4 || tick16 === 12) s = true;
      if (tick16 % 2 === 0) h = true;
    } else {
      // 激しい: 4つ打ち + 細かいハット
      if (tick16 % 4 === 0) k = true;
      if (tick16 === 4 || tick16 === 12) s = true;
      h = true;
    }

    if (k) kick.triggerAttackRelease("C1", "8n", time);
    if (s) snare.triggerAttackRelease("8n", time);
    if (h) hihat.triggerAttackRelease("32n", time, (tick16 % 4 === 0 ? 1 : 0.2)); // アクセント

  }, "16n");
}

// ===============================
// 5. 再生ボタン制御 (AudioContext + Permission)
// ===============================
playBtn.addEventListener('click', async () => {
  
  if (!isPlaying) {
    // --- START ---
    
    // 1. AudioContextの開始 (ユーザー操作必須)
    await Tone.start();
    
    // 2. センサー許可 (まだなら聞く)
    if (!permissionGranted) {
      await requestMotionPermission();
    }

    // 3. 再生開始
    setupMusicSchedule();
    Tone.Transport.start();
    
    isPlaying = true;
    playBtn.innerText = "STOP";
    playBtn.style.background = "#ff0099";
    playBtn.style.boxShadow = "0 0 15px rgba(255, 0, 153, 0.5)";
    
    // ループ開始
    updateParams();

  } else {
    // --- STOP ---
    Tone.Transport.stop();
    // センサーのリスナーは解除しても良いが、再開時にスムーズにするためつけっぱなしにする設計も可。
    // ここではバッテリー節約のため解除する場合の例：
    window.removeEventListener('devicemotion', handleMotion); 
    permissionGranted = false; // 次回また確実につなぐため（iOSの仕様によるが念のため）

    isPlaying = false;
    playBtn.innerText = "START";
    playBtn.style.background = "#00d2ff";
    playBtn.style.boxShadow = "0 0 15px rgba(0, 210, 255, 0.5)";
    
    bpmDisplay.innerText = "--";
    statusText.innerText = "STOPPED";
    meterEl.style.width = "0%";
    sensorVariance = 0;
    smoothedVariance = 0;
  }
});

</script>
</body>
</html>